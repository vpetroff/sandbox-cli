---
title: 'Node.js Application'
description: 'Deploy a complete Node.js application with Express and database'
---

## Overview

This example demonstrates deploying a full-featured Node.js application with Express, database integration, and proper production configuration using Sandbox CLI.

<CardGroup cols={2}>
  <Card
    title="Express API"
    icon="server"
  >
    RESTful API with middleware and routing
  </Card>
  <Card
    title="Database Integration"
    icon="database"
  >
    SQLite with Prisma ORM
  </Card>
  <Card
    title="Health Checks"
    icon="heart-pulse"
  >
    Built-in health and readiness endpoints
  </Card>
  <Card
    title="Production Ready"
    icon="shield-check"
  >
    Logging, error handling, and security
  </Card>
</CardGroup>

## Project Structure

```
my-node-app/
├── src/
│   ├── controllers/
│   │   ├── health.js
│   │   └── users.js
│   ├── middleware/
│   │   ├── auth.js
│   │   └── logging.js
│   ├── models/
│   │   └── user.js
│   ├── routes/
│   │   ├── health.js
│   │   └── users.js
│   └── app.js
├── prisma/
│   ├── schema.prisma
│   └── migrations/
├── tests/
│   ├── health.test.js
│   └── users.test.js
├── package.json
├── Dockerfile
├── .dockerignore
└── README.md
```

## Application Code

### Package Configuration

<CodeGroup>
```json package.json
{
  "name": "my-node-app",
  "version": "1.0.0",
  "description": "Example Node.js application for Sandbox CLI",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:seed": "node prisma/seed.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "morgan": "^1.10.0",
    "compression": "^1.7.4",
    "express-rate-limit": "^6.8.1",
    "@prisma/client": "^5.0.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.1",
    "joi": "^17.9.2",
    "winston": "^3.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.1",
    "supertest": "^6.3.3",
    "eslint": "^8.45.0",
    "prisma": "^5.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

```javascript src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
const rateLimit = require('express-rate-limit');

const healthRoutes = require('./routes/health');
const userRoutes = require('./routes/users');
const { logger } = require('./middleware/logging');
const { errorHandler } = require('./middleware/error');

const app = express();
const port = process.env.PORT || 8080;

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
  credentials: true
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP'
});
app.use(limiter);

// General middleware
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(morgan('combined', { stream: { write: message => logger.info(message.trim()) } }));

// Routes
app.use('/health', healthRoutes);
app.use('/api/users', userRoutes);

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    name: 'My Node.js App',
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString()
  });
});

// Error handling
app.use(errorHandler);

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Not Found',
    message: `Route ${req.originalUrl} not found`
  });
});

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');
  process.exit(0);
});

app.listen(port, '0.0.0.0', () => {
  logger.info(`Server running on port ${port}`);
  logger.info(`Environment: ${process.env.NODE_ENV || 'development'}`);
});

module.exports = app;
```
</CodeGroup>

### Health Check Implementation

<CodeGroup>
```javascript src/routes/health.js
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const router = express.Router();

const prisma = new PrismaClient();

// Basic health check
router.get('/', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    version: process.version
  });
});

// Readiness check (includes database)
router.get('/ready', async (req, res) => {
  try {
    // Check database connection
    await prisma.$queryRaw`SELECT 1`;
    
    res.json({
      status: 'ready',
      timestamp: new Date().toISOString(),
      checks: {
        database: 'connected',
        memory: process.memoryUsage().heapUsed < 100 * 1024 * 1024 // < 100MB
      }
    });
  } catch (error) {
    res.status(503).json({
      status: 'not ready',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});

// Liveness check
router.get('/live', (req, res) => {
  res.json({
    status: 'alive',
    timestamp: new Date().toISOString()
  });
});

module.exports = router;
```

```javascript src/controllers/health.js
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

class HealthController {
  static async getHealth(req, res) {
    try {
      const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        version: process.version,
        environment: process.env.NODE_ENV || 'development'
      };

      res.json(health);
    } catch (error) {
      res.status(500).json({
        status: 'unhealthy',
        error: error.message
      });
    }
  }

  static async getReadiness(req, res) {
    try {
      // Perform readiness checks
      const checks = {
        database: await HealthController.checkDatabase(),
        memory: HealthController.checkMemory(),
        disk: HealthController.checkDisk()
      };

      const isReady = Object.values(checks).every(check => check.status === 'ok');

      res.status(isReady ? 200 : 503).json({
        status: isReady ? 'ready' : 'not ready',
        timestamp: new Date().toISOString(),
        checks
      });
    } catch (error) {
      res.status(503).json({
        status: 'not ready',
        error: error.message
      });
    }
  }

  static async checkDatabase() {
    try {
      await prisma.$queryRaw`SELECT 1`;
      return { status: 'ok', message: 'Database connected' };
    } catch (error) {
      return { status: 'error', message: error.message };
    }
  }

  static checkMemory() {
    const usage = process.memoryUsage();
    const maxHeap = 512 * 1024 * 1024; // 512MB limit
    
    return {
      status: usage.heapUsed < maxHeap ? 'ok' : 'warning',
      heapUsed: usage.heapUsed,
      heapTotal: usage.heapTotal,
      external: usage.external
    };
  }

  static checkDisk() {
    // Simplified disk check
    return { status: 'ok', message: 'Disk space sufficient' };
  }
}

module.exports = HealthController;
```
</CodeGroup>

### User API Implementation

<CodeGroup>
```javascript src/routes/users.js
const express = require('express');
const UserController = require('../controllers/users');
const { authenticate } = require('../middleware/auth');
const { validateUser } = require('../middleware/validation');

const router = express.Router();

// Public routes
router.post('/register', validateUser, UserController.register);
router.post('/login', UserController.login);

// Protected routes
router.use(authenticate);
router.get('/', UserController.getUsers);
router.get('/:id', UserController.getUser);
router.put('/:id', validateUser, UserController.updateUser);
router.delete('/:id', UserController.deleteUser);

module.exports = router;
```

```javascript src/controllers/users.js
const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { logger } = require('../middleware/logging');

const prisma = new PrismaClient();

class UserController {
  static async register(req, res) {
    try {
      const { email, password, name } = req.body;

      // Check if user exists
      const existingUser = await prisma.user.findUnique({
        where: { email }
      });

      if (existingUser) {
        return res.status(400).json({
          error: 'User already exists'
        });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 12);

      // Create user
      const user = await prisma.user.create({
        data: {
          email,
          password: hashedPassword,
          name
        },
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true
        }
      });

      logger.info(`User registered: ${email}`);

      res.status(201).json({
        message: 'User created successfully',
        user
      });
    } catch (error) {
      logger.error('Registration error:', error);
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }

  static async login(req, res) {
    try {
      const { email, password } = req.body;

      // Find user
      const user = await prisma.user.findUnique({
        where: { email }
      });

      if (!user || !await bcrypt.compare(password, user.password)) {
        return res.status(401).json({
          error: 'Invalid credentials'
        });
      }

      // Generate JWT
      const token = jwt.sign(
        { userId: user.id, email: user.email },
        process.env.JWT_SECRET || 'fallback-secret',
        { expiresIn: '24h' }
      );

      logger.info(`User logged in: ${email}`);

      res.json({
        message: 'Login successful',
        token,
        user: {
          id: user.id,
          email: user.email,
          name: user.name
        }
      });
    } catch (error) {
      logger.error('Login error:', error);
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }

  static async getUsers(req, res) {
    try {
      const users = await prisma.user.findMany({
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true
        }
      });

      res.json({ users });
    } catch (error) {
      logger.error('Get users error:', error);
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }

  static async getUser(req, res) {
    try {
      const { id } = req.params;

      const user = await prisma.user.findUnique({
        where: { id: parseInt(id) },
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true
        }
      });

      if (!user) {
        return res.status(404).json({
          error: 'User not found'
        });
      }

      res.json({ user });
    } catch (error) {
      logger.error('Get user error:', error);
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }

  static async updateUser(req, res) {
    try {
      const { id } = req.params;
      const { name, email } = req.body;

      const user = await prisma.user.update({
        where: { id: parseInt(id) },
        data: { name, email },
        select: {
          id: true,
          email: true,
          name: true,
          updatedAt: true
        }
      });

      logger.info(`User updated: ${user.email}`);

      res.json({
        message: 'User updated successfully',
        user
      });
    } catch (error) {
      logger.error('Update user error:', error);
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }

  static async deleteUser(req, res) {
    try {
      const { id } = req.params;

      await prisma.user.delete({
        where: { id: parseInt(id) }
      });

      logger.info(`User deleted: ${id}`);

      res.json({
        message: 'User deleted successfully'
      });
    } catch (error) {
      logger.error('Delete user error:', error);
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }
}

module.exports = UserController;
```
</CodeGroup>

## Docker Configuration

<CodeGroup>
```dockerfile Dockerfile
# Multi-stage build for production optimization
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies for build)
RUN npm ci

# Copy source code
COPY . .

# Generate Prisma client
RUN npx prisma generate

# Production stage
FROM node:18-alpine AS production

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create app user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodeuser -u 1001

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install only production dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy built application from builder stage
COPY --from=builder /app/src ./src
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma

# Create necessary directories and set permissions
RUN mkdir -p /app/logs && chown -R nodeuser:nodejs /app

# Switch to non-root user
USER nodeuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Use dumb-init to handle signals properly
ENTRYPOINT ["dumb-init", "--"]

# Start the application
CMD ["npm", "start"]
```

```dockerignore .dockerignore
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.env.local
.env.development
.env.test
coverage
.nyc_output
.cache
.parcel-cache
.DS_Store
*.log
logs
*.tgz
.vscode
.idea
```
</CodeGroup>

## Database Schema

<CodeGroup>
```prisma prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}
```

```javascript prisma/seed.js
const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');

const prisma = new PrismaClient();

async function main() {
  console.log('Seeding database...');

  // Create test users
  const hashedPassword = await bcrypt.hash('password123', 12);

  const users = await Promise.all([
    prisma.user.create({
      data: {
        email: 'admin@example.com',
        name: 'Admin User',
        password: hashedPassword
      }
    }),
    prisma.user.create({
      data: {
        email: 'user@example.com',
        name: 'Regular User',
        password: hashedPassword
      }
    })
  ]);

  console.log('Created users:', users);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```
</CodeGroup>

## Testing

<CodeGroup>
```javascript tests/health.test.js
const request = require('supertest');
const app = require('../src/app');

describe('Health Endpoints', () => {
  test('GET /health should return healthy status', async () => {
    const response = await request(app)
      .get('/health')
      .expect(200);

    expect(response.body).toHaveProperty('status', 'healthy');
    expect(response.body).toHaveProperty('timestamp');
    expect(response.body).toHaveProperty('uptime');
  });

  test('GET /health/ready should return readiness status', async () => {
    const response = await request(app)
      .get('/health/ready')
      .expect(200);

    expect(response.body).toHaveProperty('status', 'ready');
    expect(response.body).toHaveProperty('checks');
  });

  test('GET /health/live should return liveness status', async () => {
    const response = await request(app)
      .get('/health/live')
      .expect(200);

    expect(response.body).toHaveProperty('status', 'alive');
  });
});
```

```javascript tests/users.test.js
const request = require('supertest');
const app = require('../src/app');

describe('User API', () => {
  let authToken;
  let userId;

  beforeAll(async () => {
    // Register a test user
    const registerResponse = await request(app)
      .post('/api/users/register')
      .send({
        email: 'test@example.com',
        password: 'password123',
        name: 'Test User'
      });

    expect(registerResponse.status).toBe(201);

    // Login to get token
    const loginResponse = await request(app)
      .post('/api/users/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      });

    expect(loginResponse.status).toBe(200);
    authToken = loginResponse.body.token;
    userId = loginResponse.body.user.id;
  });

  test('POST /api/users/register should create new user', async () => {
    const response = await request(app)
      .post('/api/users/register')
      .send({
        email: 'newuser@example.com',
        password: 'password123',
        name: 'New User'
      })
      .expect(201);

    expect(response.body).toHaveProperty('message', 'User created successfully');
    expect(response.body.user).toHaveProperty('email', 'newuser@example.com');
  });

  test('POST /api/users/login should authenticate user', async () => {
    const response = await request(app)
      .post('/api/users/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(200);

    expect(response.body).toHaveProperty('token');
    expect(response.body).toHaveProperty('message', 'Login successful');
  });

  test('GET /api/users should return users list', async () => {
    const response = await request(app)
      .get('/api/users')
      .set('Authorization', `Bearer ${authToken}`)
      .expect(200);

    expect(response.body).toHaveProperty('users');
    expect(Array.isArray(response.body.users)).toBe(true);
  });

  test('GET /api/users/:id should return specific user', async () => {
    const response = await request(app)
      .get(`/api/users/${userId}`)
      .set('Authorization', `Bearer ${authToken}`)
      .expect(200);

    expect(response.body.user).toHaveProperty('id', userId);
    expect(response.body.user).toHaveProperty('email', 'test@example.com');
  });
});
```
</CodeGroup>

## Deployment with Sandbox CLI

### Step 1: Create Sandbox

<CodeGroup>
```bash Create with Daytona
npm run cli create ./my-node-app --provider daytona
```

```bash Create with Azure
npm run cli create ./my-node-app --provider azure
```
</CodeGroup>

### Step 2: Deploy and Test

<CodeGroup>
```bash Deploy Application
npm run cli deploy ./my-node-app
```

```bash Test Health Endpoints
npm run cli execute "curl http://localhost:8080/health"
npm run cli execute "curl http://localhost:8080/health/ready"
npm run cli execute "curl http://localhost:8080/health/live"
```

```bash Test API Endpoints
# Test root endpoint
npm run cli execute "curl http://localhost:8080/"

# Register a user
npm run cli execute "curl -X POST http://localhost:8080/api/users/register \
  -H 'Content-Type: application/json' \
  -d '{\"email\":\"test@example.com\",\"password\":\"password123\",\"name\":\"Test User\"}'"

# Login
npm run cli execute "curl -X POST http://localhost:8080/api/users/login \
  -H 'Content-Type: application/json' \
  -d '{\"email\":\"test@example.com\",\"password\":\"password123\"}'"
```
</CodeGroup>

### Step 3: Development Workflow

<CodeGroup>
```bash Run Tests
npm run cli execute "npm test"
npm run cli execute "npm run test:coverage"
```

```bash Database Operations
npm run cli execute "npm run db:generate"
npm run cli execute "npm run db:migrate"
npm run cli execute "npm run db:seed"
```

```bash Monitor Application
npm run cli execute "ps aux | grep node"
npm run cli execute "tail -f /app/logs/app.log" --timeout 60
npm run cli execute "curl -w '%{time_total}' http://localhost:8080/health"
```

```bash Debug Issues
npm run cli execute "npm run lint"
npm run cli execute "node --version"
npm run cli execute "npm list"
npm run cli execute "cat /app/logs/error.log"
```
</CodeGroup>

## Production Considerations

### Environment Variables

<CodeGroup>
```bash Production Environment
NODE_ENV=production
PORT=8080
JWT_SECRET=your-super-secret-jwt-key
DATABASE_URL=file:./prod.db
LOG_LEVEL=info
ALLOWED_ORIGINS=https://yourdomain.com,https://api.yourdomain.com
```

```dockerfile Environment in Dockerfile
ENV NODE_ENV=production
ENV LOG_LEVEL=info
ENV JWT_SECRET=change-this-in-production
```
</CodeGroup>

### Monitoring and Logging

<CodeGroup>
```bash Monitor Performance
npm run cli execute "top -n 1"
npm run cli execute "free -h"
npm run cli execute "df -h"
npm run cli execute "netstat -tulpn | grep 8080"
```

```bash Application Metrics
npm run cli execute "curl http://localhost:8080/health/ready"
npm run cli execute "ab -n 100 -c 10 http://localhost:8080/"
npm run cli execute "curl -w '@curl-format.txt' -s http://localhost:8080/"
```
</CodeGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Python Application"
    icon="python"
    href="/examples/python-app"
  >
    Deploy a Python Flask application
  </Card>
  <Card
    title="Docker Compose"
    icon="docker"
    href="/examples/docker-compose"
  >
    Multi-service applications
  </Card>
  <Card
    title="Best Practices"
    icon="star"
    href="/guides/best-practices"
  >
    Optimize your deployment workflow
  </Card>
  <Card
    title="Troubleshooting"
    icon="wrench"
    href="/guides/troubleshooting"
  >
    Solve common deployment issues
  </Card>
</CardGroup>